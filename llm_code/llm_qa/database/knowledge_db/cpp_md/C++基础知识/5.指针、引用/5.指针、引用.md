# 5.指针、引用

> **详述**：指针和引用有什么区别？什么情况下用指针，什么情况下用引用？

# 1.何为指针？

指针是指向另外一种类型的符合类型，指针本身就是一个对象，允许对指针进行赋值和拷贝；指针无需在定义时赋初值。

## 1.1指针定义：（&为取地址操作符）

```c++
int num = 1;
int *p = &num;
```

利用指针访问对象；使用解引用操作符" \*"，结果为1

```c++
std::cout << *p << std::endl;
```

**指针的状态：**(指针可以作为哪种形式)

-   指向一个对象
-   指向紧邻对象所占空间的下一个位置
-   空指针int\* p = nullptr;
-   无效指针

指针作为条件判断参数：

```c++
if(p)
{}
```

只要指针p不是0，那么条件就为真。两个类型相同的指针，可以用"=="或"！="进行比较。若两个指针存放的地址相同，则它们相等，否则不等。

## 1.2指针进阶

指向指针的指针：由于指针是对象，所以指针也有自己的地址，因此可以把一个指针指向另一个指针。下面结果皆为9，指向同一地址。

```c++
int i = 9;
int *p1 = &i;
int **p2 = &p1;
cout<<i<<endl;
cout<<*p1<<endl;
cout<<**p2<<endl;
```

## 1.3指针与const限定符

指向常量的指针（pointer to const）是说这个指针是一个普通的指针，它指向常量。如果你愿意，它可以指向其他对象并且可以令一个指向常量的指针指向另一个非常量。

```c++
const double pi=3.1415;
double *p1 = &pi;//error for p1 is a general pointer
const double *p2=&pi;//correct； and p2 can poinnt to other objects
*p2=6.28;//error for pi is a const variable and p2 is const
```

常量指针（constpointer）是说这个指针本身就是一个常量对象，所以它不能指向其他对象，但是不意味着它不能改变所指向对象的值。

```c++
int num=9;
int *const p1=&num;//correct, but remember that p1 cannot point to other objects
*p1=18;//correct. You can use the const pointer to change the value of a unconst variableconst 
double e=2.71;
const double *const p2=&e;//p2 is a const pointer points to a const object
```

## 1.4指针形参

当使用指针作为函数参数的时候，执行的是指针拷贝的操作，拷贝的是指针的值。拷贝之后两个指针是不同的指针，但是它们所指向的对象是一样的，因此可以通过操作指针来改变指针所指向对象的值。

```c++
void change(int *p)
{
    *p = 32;
}
```

## 1.5限制指针的功能

很多情况下我们使用指针是为了避免拷贝对象，但是并不希望更改对象的值。这种情况下，使用const限定符限制指针的功能是一个不错的选择。指针不可再改变

```c++
void change(const int *p)
{
    *p = 32;//此段语句会出错
}
```

注意事项：指针在生命周期内随时都可能是空指针，所以在每次使用时都要做检查，防止出现空指针异常问题。

而引用却不需要做检查，因为引用永远都不会为空，它一定有本体，一定得代表某个对象，引用在创建的同时必须被初始化。指针存放的是地址，指针可以被重新赋值，可以在初始化时指向一个对象，在其它时刻也可以指向另一个对象，而引用非常专一，它会从一而终，它总是指向它最初代表的那个对象。

# 2.何为引用？

引用是某一个变量或对象的别名(好比人的绰号，不管有多少个绰号，指的都是同一个人)。

看看它的语法定义格式：`类型& 引用名=目标变量名`。

## 2.1变量名和地址

变量名是指内存空间的名字(好比人的名字)，地址是指内存空间的编号(好比人的身份证号码)，通过变量名或者地址都能获取这块内存空间的内容(就好比通过名字或者身份证都能找到这个人)。

## 2.2指针

指针就像是其他变量一样，那为什么不直接叫变量呢？与变量不同的是，指针存储的不是真实内容，而是要访问内容的地址。

## 2.3解引用

解引用就是取内存地址里的具体值

取地址和引用都是用&符号，定义指针变量和解引用都是用\*符号，那么怎么区分呢？

可以看出等号右边用&表示的是取地址，等号左边用&表示的是引用的定义；等号右边用表示的是解引用，等号左边用表示的是指针变量的定义

# 3.指针与引用的区别？

指针和引用的区别

-   指针是一块内存的地址值，而引用是一块内存的别名；
-   使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；sizeof引用得到的是所指向的变量(对象)的大小，而sizeof pointer"得到的是指针本身的大小，在64位机器下为8字节；
-   作为参数传递时，指针需要被解引用(\*p)才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
-   可以有const指针，但是没有const引用；
-   指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变（指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变）；
-   作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
-   指针可以有多级指针（\*\*p），而引用只有一级；
-   指针和引用的自增(++)运算意义不一样；
-   如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

注意：当给函数传入大型对象时，如对函数传入一个类Set set对象。当大型对象被传递给函数时，使用引用参数可使参数传递效率得到提高，因为引用并不产生对象的副本，也就是参数传递时，对象无须复制。即引用参数的二种形式：传递可变参数、给函数传递大型参数。

在程序编译的时候，将指针和引⽤添加到符号表中。

指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将"`指针变量名-指针变量的地址`"添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有const和⾮const区别，甚⾄可以为空，sizeof指针得到的是指针类型的⼤⼩。

⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将"`引⽤变量名-引⽤对象的地址`"添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有const和⾮const区别。

sizeof引⽤得到代表对象的⼤⼩。⽽sizeof指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。

作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引⽤的实质是传地址，传递的是变量的地址

指针与引用都提供了间接操作对象的功能。

1.  指针定义时可以不初始化，而引用在定义时就要初始化，和一个对象绑定，而且一经绑定只要引用存在，就会一直保持和该对象的绑定。
2.  赋值行为的差异：指针赋值是将指针重新指向另一个对象，而引用赋值则是将修改对象本身。
3.  指针之间存在类型转换，而引用分const引用和非const引用，非const引用只能和同类型的对象绑定，const引用可以绑定到不同但相关类型的对象或者右值。
4.  什么时候用指针或引用呢？

引用主要功能是作为函数的参数和返回值

```c++
vector<int> vec(10);
vec[3] = 3;
```

为什么通过vec\[3]=3可以改变vector容器的值，因为\[]操作符返回的就是引用，相当于为内部的变量起了一个别名，这里还可以让\[]操作符返回一个指针，即\*vec\[3]=3，这是不是有点丑，而且不符合语法需求。

其实我们平时编程过程中可能也注意到，实际上引用可以做的事情指针都可以做，但为什么还要引用这个东西？

用恰当的工具做恰如其分的工作，指针可以毫无约束的操作内存中的任何东西，功能十分强大，但是也很危险，所以可以在恰当的时机使用引用，当你需要指向某个东西，而且一定专一，绝不会让其指向其它东西，例如有些函数参数为了避免拷贝可以使用引用，或者实现一个操作符而其语法需求无法由指针达成，例如vec\[3]=3，可以使用引用，其它任何时候，都要使用指针。
