# 4.虚函数

virtual函数的实现原理

C++通过虚函数表和虚函数表指针来实现virtual function机制，具体如下：

-   对于一个class，产生一堆指向virtual function的指针，这些指针被放在一个表格中，称为虚函数表（virtual table，vtbl）
-   每个对象中都添加一个指针，指向相关的virtual table。通常在这个指针被称为虚函数表指针(vptr)。出于效率的考虑，在指针通常放在对象实例最前面的位置（第一个slot处）。每一个class所关联的type\_info z信息也由virtual table提出（通常放在表格的最前面）。

一些考题：

### 1、为什么调用普通函数比调用虚函数的效率高呢？

> 因为普通函数是静态联编的，而调用虚函数是动态联编的

> 联编的作用：程序调用函数，编译器决定使用哪个可执行代码块。

> **静态联编**：在编译的时候就确定了函数的地址，直接call调用即可

> **动态联编**：首先需要知道对象的首地址，在解引用取到虚函数表的首地址后，再加上偏移量才能找到调用的虚函数，然后call调用。

### 2、为什么要用虚函数表（存函数指针的数组）？

> 实现多态，父对象的指针指向其调用的虚函数，指向子类调用的子类虚函数。

> 同一个类的多个对象的虚函数是同一个，所以这样可以节省空间，一个类自己的虚函数和继承的虚函数还是重写父类的虚函数都存在自己的虚函数表中。

### 3、为什么要把基类的析构函数定义为虚函数？

> 在用基类操作派生类时，为了防止执行基类的析构函数，再不执行派生类的析构函数。因为这样的删除只能够删除基类对象，而不能删除子类对象，形成了删除一般的现象，造成内存泄漏。

### 4、为什么子类和父类的函数名不一样，还可以构成重写呢?

> 因为编译器对析构函数的名字进行了特殊处理，在内部函数名是一样的。

### 5、如果虚函数是有效的，那为什么不把所有函数设为虚函数？

> 不行。首先，虚函数是有代价的，由于每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。

### 6、以下函数不能作为虚函数

-   友元函数，它不是类的成员函数
-   全局函数
-   静态成员函数，它没有this指针
-   构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

### 7、一个类中如果有虚函数声明，那么这些函数会由一个虚函数表来维护

1.  每个父类都有自己的虚表。
2.  子类的成员函数被放到了第一个父类的表中。
3.  内存布局中，其父类布局依次按声明顺序排列。
4.  每个父类的虚表中的函数都被overwrite成了子类函数。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

编译期：虚函数的函数名符号指向是空的

运行期：虚函数的指针指向对象域，而不是类域

**虚函数一般不声明为内联函数，因为对虚函数的调用是动态的，而内联函数处理是编译期静态的。**

### 8、构造函数可以是虚函数吗？析构函数可以是虚函数吗？

> 构造函数不可以是虚函数，析构函数可以是虚函数。

> 虚函数采用一种虚调用的方法。需调用是一种可以在只有部分信息的情况下工作的机制。如果创建一个对象，则需要知道对象的准确类型，虚函数的虚调用方法不能够提供准确类型，因此构造函数不能为虚函数。

> 编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。

### 9、基类的析构函数可以调用虚函数吗？基类的构造函数可以调用虚函数吗？

> 可以，但是最好不要再构造函数与析构函数中调用，因为没有动态绑定的效果，基类构造函数中调用的依然是父类版本中的函数，子类中调用的依旧是子类版本的函数。即基类中调用虚函数直接找到基类中的实际虚函数调用，不会调用子类中的虚函数。

> 如果有继承存在，构造函数会在先调用父类构造函数，而如果构造函数中有虚函数，此时子类就没有构造，所以此时的对象还是父类的，不会触发多态。析构函数也是如此，子类先进行析构，如果有virtual函数子类的内容已经被析构了，C++会视其父类，执行其父类的virtual函数。

### 10、什么场景需要用到纯虚函数？纯虚函数的作用是什么？

> 包含纯虚函数的类称作纯接口类，用于定义抽象类，C++中没有接口类可以利用纯虚函数实现定义接口的目的。且不能声明抽象类的对象。
