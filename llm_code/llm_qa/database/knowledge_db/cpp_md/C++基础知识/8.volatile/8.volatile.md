# 8.volatile

> **详述**：volatile关键字的作用

# 1.volatile的含义：

修饰符volatile告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。

介绍：volatile提醒编译器它后面所定义的变量随时都有可能改变。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

```c++
void do1() {cout<<"this is do1"<<endl;};
void do2() {cout<<"this is do2"<<endl;};
short flag;
void test()
{
    do1();
    while(flag == 0);
    do2();
}
int main()
{
    test();
}
```

这段程序等待内存变量flag的值变为1(怀疑此处是0,有点疑问,)之后才运行do2()。变量flag的值由别的程序更改，这个程序可能是某个硬件中断服务程序。

```c++
volatile short flag;
```

需要注意的是，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了。因此经常会出现debug版本正常，但是release版本却不能正常的问题。所以为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字。

volatile的本意是"易变的",由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。

volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以死代码消除。但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化，volatile的字面含义是易变的，它有下面的作用：

1.  不会在两个操作之间把volatile变量缓存在寄存器中。在多任务、中断、甚至setjmp环境下，变量可能被其他的程序改变，编译器自己无法知道，volatile就是告诉编译器这种情况。
2.  不做常量合并、常量传播等优化，所以像下面的代码：

```c++
volatile int i = 1;
if(i > 0)
{
    cout<<"i>0"<<endl;
}
```

if的条件不会当作无条件真。

1.  对volatile变量的读写不会被优化掉。如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而对Memory Mapped IO的处理是不能这样优化的。

# 2.volatile的用途

一般说来，volatile用在如下的几个地方：

1.  中断服务程序中修改的供其它程序检测的变量需要加volatile；
2.  多任务环境下各任务间共享的标志应该加volatile；
3.  存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。

# 3.编译器优化，C关键字volatile，memory破坏描述符

## 3.1编译器优化介绍

内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。

再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memorybarrier），linux提供了一个宏解决编译器的执行顺序问题。

## 3.2 C语言关键字volatile

C语言关键字volatile（注意它是用来修饰变量而不是上面介绍的volatile）表明某个变量的值可能在外部被改变，因此对这些变量的存取不能缓存到寄存器，每次使用时需要重新存取。该关键字在多线程环境下经常使用，因为在编写多线程的程序时，同一个变量可能被多个线程修改，而程序通过该变量同步各个线程。

## 3.3 Memory

有了上面的知识就不难理解Memory修改描述符了，Memory描述符告知GCC：

1.  不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕。
2.  不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。

如果汇编指令修改了内存，但是GCC本身却察觉不到，因为在输出部分没有描述，此时就需要在修改描述部分增加"memory"，告诉GCC内存已经被修改，GCC得知这个信息后，就会在这段指令之前，插入必要的指令将前面因为优化Cache到寄存器中的变量值先写回内存，如果以后又要使用这些变量再重新读取。

使用"volatile"也可以达到这个目的，但是我们在每个变量前增加该关键字，不如使用"memory"方便。
