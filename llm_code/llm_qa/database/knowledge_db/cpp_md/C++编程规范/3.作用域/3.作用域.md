# 3.作用域

### 3.作用域

#### 3.1.命名空间

**规则**

禁止使用 using 指示（using-directive）；

禁止使用内联命名空间（`inline namespace`）；

鼓励在 `.cpp` 文件内使用匿名命名空间或`static` 声明。

**定义**

命名空间将全局作用域细分为独立的， 具名的作用域， 可有效防止全局作用域的命名冲突。

**说明**

不要在命名空间 `std` 内声明任何东西，包括标准库的类前置声明。在 `std` 命名空间声明实体是未定义的行为， 会导致如不可移植。声明标准库下的实体，需要包含对应的头文件。

不应该使用 *using 指示* 引入整个命名空间的标识符号。

```c++
// 禁止 —— 污染命名空间
using namespace std;
using namespace foo;

// 推荐使用
using std::cout;
using std::endl;
```

**示例**

```c++
// .h 文件
namespace mynamespace 
{

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass
{
public:
    ...
    void Foo();
}; // MyClass

} // namespace mynamespace
```

```c++
// .cpp 文件
namespace mynamespace 
{

// 函数定义都置于命名空间中
void MyClass::Foo() 
{
    ...
}

} // namespace mynamespace
```

#### 3.2.匿名命名空间和静态变量

**规则**

在 `.cpp` 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 `static` 。但是不要在 `.h` 文件中这么做。

**定义**

所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 `static` 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。

**说明**

推荐、鼓励在 `.cpp` 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 `.h` 中使用。

**示例**

匿名命名空间的声明和具名的格式相同，在最后注释上 `namespace` :

```c++
namespace 
{
...
}  // namespace
```

#### 3.3.非成员函数、静态成员函数和全局函数

**规则**

尽量不用全局函数，考虑作用域和命名空间限制，尽量单独形成编译单元；

将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。

**说明**

有时，把函数的定义同类的实例脱钩是有益的，甚至是必要的。 这样的函数可以被定义成静态成员，或是非成员函数。

非成员函数不应依赖于外部变量， 应尽量置于某个命名空间内。

相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。

如果必须定义非成员函数, 又只是在 `.cpp` 文件中使用它，可使用匿名命名空间或 `static` 链接关键字 (如 `static int Foo() {...}`) 限定其作用域。

#### 3.4.局部变量

**规则**

将函数变量尽可能置于最小作用域内，并在变量声明时进行初始化。

**说明**

C++ 允许在函数的任何位置声明变量。提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。 这使得代码浏览者更容易定位变量声明的位置，了解变量的类型和初始值。

属于 `if`、 `while` 和 `for` 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，例如：

```c++
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一个例外， 如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域都要调用其析构函数。 这会导致效率降低。

```c++
// 低效的实现 --- 不推荐
for (int i = 0; i < 1000000; ++i) 
{
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
```

```c++
// 推荐
Foo f;                      // 构造函数和析构函数只调用 1 次
for (int i = 0; i < 1000000; ++i) 
{
    f.DoSomething(i);
}
```

**示例**

```c++
int i;
i = f();         // 不推荐 -- 初始化和声明分离

int j = g();       // 推荐 -- 初始化时声明

vector<int> v;      //不推荐 -- 用花括号初始化更好
v.push_back(1); 
v.push_back(2);

vector<int> v = {1, 2};  // 推荐 -- v 一开始就初始化
```

#### 3.5.静态和全局变量

**规则**

禁止定义静态储存周期非POD变量；

禁止使用含有副作用的函数初始化POD全局变量；

尽量以`const`，`enum`，`inline`替换`#define`；

尽可能使用`const`。

**说明**

禁止使用类的静态储存周期变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 `constexpr` 变量除外，毕竟它们又不涉及动态初始化或析构。

静态生存周期的对象，即包括了全局变量、静态变量、静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data)：即 int、 char 和 float，以及 POD 类型的指针、数组和结构体。

静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。 所以除了禁用类类型的全局变量，也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 `getenv()` 或 `getpid()` ）不涉及任何全局变量。

同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (`unspecified behaviour`)。

同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 `main()` 返回还是对 `exit()` 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。

**示例**

```c++
const double k_Pi = 3.1415926535;
```

测试一下，那个是常量？指针p，还是数组？

```c++
char greeting[] = "Hello";
char* p = greeting;
const char* p = greeting;
char const* p = greeting;
char* const p = greeting;
const char* const p = greeting;
```
