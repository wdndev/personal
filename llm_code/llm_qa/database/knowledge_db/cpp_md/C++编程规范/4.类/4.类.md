# 4.类

### 4.类

#### 4.1.构造/析构函数

**规则**

禁止在构造或析构过程中调用虚函数；

禁止在无法报出错误时进行可能失败的初始化；

若不想使用编译器自动生成的函数，就该明确的拒绝。

**定义**

在构造函数中可以进行各种初始化操作。

**说明**

如果在构造函数内调用了自身的虚函数， 这类调用是不会重定向到子类的虚函数实现。 即使当前没有子类化实现，将来仍是隐患。

#### 4.2.隐式类型转换

**规则**

禁止定义隐式类型转换。对于转换运算符和单参数构造函数，请使用 `explicit` 关键字。

**定义**

隐式类型转换允许一个某种类型 (称作 *源类型*) 的对象被用于需要另一种类型 (称作 *目的类型*) 的位置, 例如, 将一个 `int` 类型的参数传递给需要 `double` 类型的函数。

**说明**

`explicit` 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符，以保证只有当目的类型在调用点被显式写明时才能进行类型转换。

在类型定义中，类型转换运算符和单参数构造函数都应当用 `explicit` 进行标记。一个例外是， 拷贝和移动构造函数不应当被标记为 `explicit`，因为它们并不执行类型转换。

**示例**

```c++
class Foo 
{
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
```

此时，下面的代码是不允许的：

```c++
Func({42, 3.14});  // 错误
```

#### 4.3.可拷贝类型和可移动类型

**规则**

如果你的类型需要，就让它们支持拷贝 / 移动。 否则，就把隐式产生的拷贝和移动函数禁用。

**定义**

可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值，或在赋值时被赋予相同类型的另一对象的值，同时不改变源对象的值。

可移动类型允许对象在初始化时得到来自相同类型的临时对象的值，或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的。

拷贝 / 移动构造函数在某些情况下会被编译器隐式调用。

**说明**

如果让类型可拷贝。 一定要同时给出拷贝构造函数和赋值操作的定义。

如果你的类不需要拷贝 / 移动操作， 请显式地通过在 `public` 域中使用 `= delete` 或其他手段禁用。

#### 4.4.结构体 VS 类

**规则**

仅当只有数据成员时使用 `struct`，其它一概使用 `class`。

**说明**

在 C++ 中 `struct` 和 `class` 关键字几乎含义一样。我们为这两个关键字添加我们自己的语义理解， 以便为定义的数据类型选择合适的关键字。

`struct` 用来定义包含数据的被动式对象，也可以包含相关的常量，但除了存取数据成员之外，没有别的函数功能。除了构造函数、析构函数、`Initialize()`、`Reset()`、`Validate()` 等类似的用于设定数据成员的函数外，不能提供其它功能的函数。

如果需要更多的函数功能， `class` 更适合。如果拿不准， 就用 `class`。

#### 4.5.继承

**规则**

使用组合常常比使用继承更合理。如果使用继承的话，定义为 `public` 继承。

**定义**

当子类继承基类时，子类包含了父基类所有数据及操作的定义。继承主要用于两种场合：实现继承，子类继承父类的实现代码； 接口继承，子类仅继承父类的方法名称。

子类多态重载父类的方法时，在方法后面必须加`override`关键字。

**说明**

所有继承必须是 `public` 的。如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式。

必要的话， 析构函数声明为 `virtual`。如果你的类有虚函数，则析构函数也应该为虚函数。

**示例**

```c++
// 纯接口类
class ICompany
{
public:
    virtual void test_inferface() = 0;
}; // ICompany

class GREE : public ICompany
{
public:
    void test_inferface() override;
};
```

#### 4.6.多重继承

**规则**

只在以下情况我们才允许多重继承： 最多只有一个基类是非抽象类； 其它基类都是以 字母`I` 开头的纯接口类。

**定义**

多重继承允许子类拥有多个基类。要将作为 *纯接口* 的基类和具有 *实现* 的基类区别开来。

**说明**

只有当所有父类除第一个外都是纯接口类时，才允许使用多重继承。为确保它们是纯接口， 这些类必须以字母 `I` 开头。

#### 4.7.接口

**规则**

接口是指满足特定条件的类， 这些类以 字母`I` 为开头。

**定义**

当一个类满足以下要求时，称之为纯接口：

-   只有纯虚函数 (“`=0`”) 和静态函数 (除了下文提到的析构函数)；
-   没有非静态数据成员；
-   没有定义任何构造函数。如果有，也不能带有参数，并且必须为 `protected`；
-   如果它是一个子类，也只能从满足上述条件并以 `I` 开头的类继承。

接口类不能被直接实例化， 因为它声明了纯虚函数。 为确保接口类的所有实现可被正确销毁，必须为之声明虚析构函数 。

**说明**

只有在满足上述条件时，类才以字母 `I` 开头， 但反过来。

**示例**

```c++
// 纯接口类
class ICompany
{
public:
    virtual void test_inferface() = 0;
}; // ICompany
```

#### 4.8.运算符重载

**规则**

除少数特定环境外，不要重载运算符。 也不要创建用户定义字面量。

**定义**

C++ 允许用户通过使用 `operator` 关键字对内建运算符进行重载定义，只要其中一个参数是用户定义的类型。`operator` 关键字还允许用户使用 `operator""` 定义新的字面运算符， 并且定义类型转换函数, 例如 `operator bool()`。

**说明**

只有在意义明显， 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符。

只有对用户自己定义的类型重载运算符。更准确地说，将它们和它们所操作的类型定义在同一个头文件中，`.cpp` 中和命名空间中。 这样做无论类型在哪里都能够使用定义的运算符， 并且最大程度上避免了多重定义的风险。 如果可能的话， 请避免将运算符定义为模板，因为此时它们必须对任何模板参数都能够作用。

#### 4.9.声明顺序

**规则**

将相似的声明放在一起， 建议将 `public` 部分放在最前。

**说明**

类定义一般应以 `public:` 开始， 后跟 `protected:`，最后是 `private:`。

在各个部分中， 建议将类似的声明放在一起，并且建议以如下的顺序：类型 (包括 `typedef`， `using` 和嵌套的结构体与类)、 常量, 、工厂函数、 构造函数、 赋值运算符、析构函数、 其它函数、数据成员。
