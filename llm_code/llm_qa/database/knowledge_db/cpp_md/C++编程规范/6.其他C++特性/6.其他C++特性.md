# 6.其他C++特性

### 6.C++其他特性

#### 6.1.引用传参

**规则**

所有按引用传递的输入参数必须加上 `const`。

**说明**

在 C 语言中，如果函数需要修改变量的值，参数必须为指针， 如 `int foo(int *pval)`。在 C++ 中， 函数还可以声明引用参数： `int foo(int &val)`。

**示例**

```c++
return_type Foo(const string &in, string *out);
```

获取、设置类私有变量成员的函数传入传出参数不使用引用，指针传递；

```c++
void set_inputname(const std::string input_name);
std::string get_inputname(); 
```

`OpenCV`中，`Mat`类型从函数传出，可使用引用传递：

```c++
infer_ret_t start_infer(const cv::Mat& frame, float threshold, cv::Mat& result)；
```

#### 6.2.函数重载

**规则**

若要使用函数重载，则必须能让读者一看调用点就胸有成竹，而不用花心思猜测调用的重载函数到底是哪一种，这一规则也适用于构造函数。

**定义**

你可以编写一个参数类型为 `const string&` 的函数，然后用另一个参数类型为 `const char*` 的函数对其进行重载：

```c++
class MyClass 
{
public:
    void Analyze(const string &text);
    void Analyze(const char *text, size_t textlen);
};
```

**说明**

如果打算重载一个函数，可以试试改在函数名里加上参数信息。例如，用 `AppendString()` 和 `AppendInt()` 等，而不是一口气重载多个 `Append()`。如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 `std::vector` 以便使用者可以用`列表初始化`指定参数。

#### 6.3.友元

**规则**

允许合理的使用友元类及友元函数。

**说明**

通常友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类。经常用到友元的一个地方是将 `FooBuilder` 声明为 `Foo` 的友元，以便 `FooBuilder` 正确构造 `Foo` 的内部状态，而无需将该状态暴露出来。某些情况下， 将一个单元测试类声明成待测类的友元会很方便。

友元扩大了 (但没有打破) 类的封装边界。 某些情况下， 相对于将类成员声明为 `public`， 使用友元是更好的选择，尤其是如果你只允许另一个类访问该类的私有成员时。 当然， 大多数类都只应该通过其提供的公有成员进行互操作。

#### 6.4.异常

**规则**

不推荐使用异常，如果使用异常，请说明函数执行失败在不可控范围内。

**说明**

异常是处理构造函数失败的唯一途径。异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码。

异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。

#### 6.5.类型转换

**规则**

推荐使用 C++ 的类型转换， 如 `static_cast<>()`。禁止使用 `int y = (int)x` 或 `int y = int(x)` 等转换方式。

**说明**

C++ 采用了有别于 C 的类型转换机制， 对转换操作进行归类；C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 `(int)3.5`)， 有时是在做类型转换 (如 `(int)"hello"`)。 另外， C++ 的类型转换在查找时更醒目。

禁止使用 C 风格类型转换，而应该使用 C++ 风格：

-   用 `static_cast` 替代 C 风格的值转换，或某个类指针需要明确的向上转换为父类指针时；
-   用 `const_cast` 去掉 `const` 限定符；
-   用 `reinterpret_cast` 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用。

#### 6.6.`const`用法

**规则**

强烈建议你在任何可能的情况下都要使用 `const`，此外有时改用 C++11 推出的 `constexpr `更好。

**说明**

声明的变量或参数前加上关键字 `const` 用于指明变量值不可被篡改 (如 `const int foo` )。 为类中的函数加上 `const` 限定符表明该函数不会修改类成员变量的状态。

`const` 变量、数据成员、 函数和参数为编译时类型检测增加了一层保障； 便于尽早发现错误。因此，强烈建议在任何可能的情况下使用 `const`：

-   如果函数不会修改传你入的引用或指针类型参数，该参数应声明为 `const`.
-   尽可能将函数声明为 `const`，访问函数应该总是 `const`，其他不会修改任何数据成员， 未调用非 `const` 函数，不会返回数据成员非 `const` 指针或引用的函数也应该声明成 `const`。
-   如果数据成员在对象构造之后不再发生变化， 可将其定义为 `const`。

#### 6.7.代码的可移植性

**规则**

代码应该对 64 位、 32 位和Windows、Linux系统友好。

**说明**

如果你确实需要 `32` 位和 `64` 位系统具有不同代码， 可以使用 `#ifdef _LP64` 指令来切分 32/64 位代码。(尽量不要这么做， 如果非用不可，尽量使修改局部化)；

如果你确实需要`Windows`和 `Linux`系统具有不同代码， 可以使用 `#ifdef WIN32 ` 指令来切分`Windows`和`Linux`系统。(尽量不要这么做， 如果非用不可，尽量使修改局部化).

#### 6.8.预处理宏

**规则**

使用宏时要非常谨慎， 尽量以内联函数、 枚举和常量代替之。

**说明**

宏意味着你和编译器看到的代码是不同的。这可能会导致异常行为，尤其因为宏具有全局作用域。

如果你要宏，尽可能遵守：

-   不要在 `.h` 文件中定义宏；
-   在马上要使用时才进行 `#define`， 使用后要立即 `#undef`；
-   不要只是对已经存在的宏使用`#undef`，选择一个不会冲突的名称；
-   不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为；
-   不要用 `##` 处理函数，类和变量的名字。

#### 6.9.`0`，`nullptr`和`NULL`

**规则**

整数用 `0`，实数用 `0.0`，指针用 `nullptr` 或 `NULL`，字符 (串) 用 `'\0'`。

**说明**

C++11 项目用 `nullptr`，C++03 项目则用 `NULL`；实际上，一些 C++ 编译器对 `NULL` 的定义比较特殊，可以输出有用的警告，特别是 `sizeof(NULL)` 就和 `sizeof(0)` 不一样。

字符 (串) 用 `'\0'`，不仅类型正确而且可读性好。

#### 6.10.`sizeof`

**规则**

尽可能用 `sizeof(varname)` 代替 `sizeof(type)`。

**说明**

使用 `sizeof(varname)` 是因为当代码中变量类型改变时会自动更新。 或许会用 `sizeof(type)` 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。

#### 6.11.`auto`

**规则**

用 `auto` 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。

**说明**

C++11 中，若变量被声明成 `auto`，那它的类型就会被自动匹配成初始化表达式的类型；

auto 在涉及迭代器的循环语句里挺常用。

#### 6.12.模板编程

**规则**

不要使用复杂的模板编程。

**说明**

模板编程指的是利用 C++  模板实例化机制是图灵完备性，可以被用来实现编译时刻的类型判断的一系列编程技巧。

模板编程有时候能够实现更简洁更易用的接口， 但是更多的时候却适得其反。 因此模板编程最好只用在少量的基础组件， 基础数据结构上， 因为模板带来的额外的维护成本会被大量的使用给分担掉。

如果你使用模板编程， 你必须考虑尽可能的把复杂度最小化， 并且尽量不要让模板对外暴漏。 你最好只在实现里面使用模板，然后给用户暴露的接口里面并不使用模板， 这样能提高你的接口的可读性，并且你应该在这些使用模板的代码上写尽可能详细的注释。
