# 1.头文件

### 1. 头文件

通常每一个 `.cpp` 文件都有一个对应的 `.h` 文件。 也有一些常见例外，如单元测试代码和只包含 `main()` 函数的 `.cpp` 文件。

头文件的设计可以体现整个项目的设计思路，正确使用头文件可令代码在可读性、文件大小和性能上大为改观。

下面的规则将引导你规避使用头文件时的各种陷阱。

#### 1.1. Self-contained头文件

**规则**

头文件应该能够自给自足（self-contained，也就是可以作为第一个头文件被引入），以 `.h` 结尾。

**说明**

所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 `1.2. #define 保护`，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols。

如果 `.h` 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 `.cpp` 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。

#### 1.2. #define保护

**规则**

所有头文件都应该使用 `#define` 来防止头文件被多重包含， 命名格式当是: `<PROJECT>_<FILE>_H` 。

**说明**

为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。

**示例**

项目 `foo` 中的头文件 `foo/src/bar/baz.h` 可按如下方式保护：

```c++
#ifndef FOO_BAZ_H
#define FOO_BAZ_H
...
#endif // FOO_BAR_H
```

#### 1.3. 前置声明

**规则**

尽可能地避免使用前置声明。使用 `#include` 包含需要的头文件即可。

**说明**

尽量避免前置声明那些定义在其他项目中的实体。

函数：总是使用 `#include`

类模板：优先使用 `#include`

**定义**

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。

**优点**

-   前置声明能够节省编译时间，多余的 `#include` 会迫使编译器展开更多的文件，处理更多的输入。
-   前置声明能够节省不必要的重新编译的时间。 `#include` 使代码因为头文件中无关的改动而被重新编译多次。

**缺点**

-   前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
-   前置声明了不少来自头文件的 symbol 时，就会比单单一行的 `include` 冗长。
-   很难判断什么时候该用前置声明，什么时候该用 `#include` 。极端情况下，用前置声明代替 `includes` 甚至都会暗暗地改变代码的含义：
    如果 `#include` 被 `B` 和 `D` 的前置声明替代， `test()` 就会调用 `f(void*)` 。
    ```c++
    // b.h:
    struct B {};
    struct D : B {};

    // good_user.cpp:
    #include "b.h"
    void f(B*);
    void f(void*);
    void test(D* x) { f(x); }  // calls f(B*)
    ```

#### 1.4.内联函数

**规则**

只有当函数只有 10 行甚至更少时才将其定义为内联函数。

**说明**

一个较为合理的经验准则是， 不要内联超过 10 行的函数。谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用！

另一个实用的经验准则： 内联那些包含循环或 `switch` 语句的函数常常是得不偿失 (除非在大多数情况下，这些循环或 `switch` 语句从不被执行)。

有些函数即使声明为内联的也不一定会被编译器内联， 这点很重要；比如虚函数和递归函数就不会被正常内联。 通常， 递归函数不应该声明成内联函数。虚函数内联的主要原因则是想把它的函数体放在类定义内， 为了图个方便， 抑或是当作文档描述其行为，比如精短的存取函数。

**定义**

当函数被声明为内联函数之后， 编译器会将其内联展开， 而不是按通常的函数调用机制进行调用。

**优点**

只要内联的函数体较小， 内联该函数可以令目标代码更加高效。 对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。

**缺点**

滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。

#### 1.5.`#include`的路径及顺序

**规则**

使用标准的头文件包含顺序可增强可读性，避免隐藏依赖： 相关头文件、C 库、C++ 库、 其他库的 .h、 本项目内的 .h。

**说明**

项目内头文件应按照项目源代码目录树结构排列，避免使用 UNIX 特殊的快捷目录 `.` (当前目录) 或 `..` (上级目录)。例如, `gats-project/src/base/logging.h` 应该按如下方式包含：

```c++
#include "base/logging.h"
```

#### 1.6.`extern`

**规则**

只能通过包含头文件的方式使用其他`.cpp`提供的接口，禁止在`.cpp`中通过`extern`的方式使用外部函数接口、变量。

禁止在`extern "C"`中包含头文件。

**说明**

若`a.cpp`使用了`b.cpp`定义的`foo()`函数，则应当在`b.h`中声明`extern int foo(int input)`；并在`a.c`中通过`#include <b.h>`来使用`foo`。禁止通过在`a.c`中直接写`extern int foo(int input);`来使用`foo`，后面这种写法容易在`foo`改变时可能导致声明和定义不一致。

在`extern "C"`中包含头文件， 会导致`extern "C"`嵌套， Visual Studio对`extern "C"`嵌套层次有限制，嵌套层次太多会编译错误。在`extern "C"`中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。

#### 1.7.其他

**规则**

禁止头文件循环依赖；

`.cpp/.h`文件禁止包含用不到的头文件；

禁止在头文件中定义变量。

**说明**

很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些项目干脆发布了一个`god.h`，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。

在头文件中定义变量，将会由于头文件被其他`.cpp`文件包含而导致变量重复定义。

**示例**

存在`a.h`和`b.h`两个头文件：

```c++
#ifndef A_H
#define A_H
#ifdef __cplusplus
void foo(int);
#define a(value) foo(value)
#else
void a(int)
#endif
#endif /* A_H */
```

```c++
#ifndef B_H
#define B_H
#ifdef __cplusplus
extern "C" {
#endif
#include "a.h"
void b();
#ifdef __cplusplus
}
#endif
#endif /* B_H */
```

使用C++预处理器展开`b.h`，将会得到

```c++
extern "C" {
void foo(int);
void b();
}
```

按照`a.h`作者的本意，函数`foo`是一个C++自由函数，其链接规范为"C++"。但在`b.h`中，由于`#include
"a.h"`被放到了`extern "C" { }`的内部，函数`foo`的链接规范被不正确地更改了。
