面试题1：赋值运算符函数
①赋值运算符函数需要使用“常引用”作为输入参数
②拷贝构造函数也需要使用“常引用”作为输入参数
③在其中进行拷贝时，为了避免new、delete，可以使用类的零时变量，然后函数结束时编译器自动释放
strcpy(m_pData, str.m_pData);

面试题2；实现Singleton模式
①懒汉式（需要的时候创建），饿汉式（一开始就创建）
类的静态成员初始化，紧跟在类的声明之后，Singleton1* Singleton1::instance = new Singleton1();
②多线程中需要上锁，上锁时先判空，锁也是静态成员，使用前需要先声明mutex Singleton2::mutex_;
#include <mutex>
lock_guard<mutex> lock(mutex_);

面试题3：数组中重复的数字
①采用hash结构，确保每个位置的数值和位置一致，但出现多个不一致，而且已经有一致时，则为重复数字
②或者统计一个数组中，1-n的数字有几个，超过n个则有重复数字，采用二分法的思想

面试题4：二维数组中的查找
①由于数组从左至右，从上之下都递增的，左右先看最右上角的数字值
②然后采用分治的思想，数字比右上角小，则去列，比右上角打，则去行

面试题5；替换空格
①先统计出字符串中空格的个数，然后可以知道最终字符串的长度
②从后往前替换，可以降低时间复杂度（从前往后，要重复的移动元素）
设置两个索引，一个用来访问原来的数据位置，一个用来指向新的数据位置

面试题6：从尾到头打印链表
使用递归的思想即可

面试题7：重建二叉树
①采用递归的方式来实现，根据“前序遍历”和“中序遍历”的内容，找到根节点，然后划分“子前序”和“子后序”，分别构造左右子树
②一直递归构造，只到子串为空，无法再构造为止
二叉树的三种遍历，都可以用递归和非递归来实现，递归实现比较简单
非递归，前序遍历，简单，一个栈即可，压根，输出根，压右，压左，然后出站输出，重复过程
非递归，中序遍历，稍复杂，一个栈即可，先找最左叶子，路径全压栈，每次出栈，转到节点右孩子的最左叶子
非递归，后序遍历，难，两个栈，一个栈用于遍历树（有进有出），一个用于输出（只进最后一次性出）
先找最右叶子，路径进栈（两个），每次遍历栈（有进有出）出栈时，转到左孩子的最右节点，最后输出栈，一次性输出

面试题8：二叉树的下一个节点
①如果当前节点右孩子不空，则下一个，为右孩子为根的最左节点
②如果当前节点右孩子为空，如果有父节点，是父节点的左子节点，则下一个，为父节点
③如果当前节点右孩子为空，如果有父节点，是父节点的右子节点，需要父节点一直向上，知道为一个左节点，则下一个为，其父节点
其实②③为一条，就是沿着该节点，一直向上找父亲，知道找到一个节点，为其父亲的左孩子，则下一个为其父亲

面试题9：用两个栈实现队列
①分为两个栈（In和Out）
②队列增加元素时，不断往In栈进栈即可
③队列减少元素是，先看Out栈是否为空，为空的话，先把In栈内容全出栈，压入Out栈；Out弹出顶上元素。
template <typename T> 模板使用，在类或函数前加这个
#include <stack>
stack <char> stackIn; 使用栈的方式

面试题10；斐波那契数列
①通过递归可以快速实现，但是代码执行效率太低了，因为存在大量的重复计算
②可以使用循环，每次吧上一次的两个值缓存下来，然后计算新的值
// 无符号类型标识unsigned，就是将负数的部分范围扩充到了正数之后
cout << "short 类型的占用字节大小：" << sizeof(short) << endl;  // short 类型的占用字节大小：2
cout << "int 类型的占用字节大小：" << sizeof(int) << endl;		// int 类型的占用字节大小：4
cout << "long 类型的占用字节大小：" << sizeof(long) << endl;	// long 类型的占用字节大小：4
cout << "long long 类型的占用字节大小：" << sizeof(long long) << endl;  //long long 类型的占用字节大小：8

面试题11：旋转数组的最小数字
①直接查找没有利用到旋转数组特性
②可以使用二分的思想，看前，中，后，三个位置的值，缩小范围查找
③前中后三个位置值相等时，无计可施，只能在其中顺序查找了
const int oldestAge = 99;
int timesofAge[oldestAge + 1];
memset(timesofAge, 0, sizeof(timesofAge));

面试题12：矩阵中的路径
利用回溯法求解
某位置是否有路径，看除去该元素后的子路径，在周围（上下左右）是否存在，不断递归下去求解

面试题13：机器人的运动范围
利用回溯法求解
当前位置可以，这总数为1+周围（上下左右）可行数

面试题14：剪绳子
①动态规划算法：f(n)=max(f(i)*f(n-i))
②贪心算法：尽可能的减出3来，3*3是最大的，知道出现余4，则要减成2*2

面试题15：二进制中1的个数
①使用位运算求解，定义掩码，一直从1开始左移<<，再和数字相与&，为1的话，那么该数有一个位为1
②更好的解法：一个数减1后与原数字做与&，则该数最右边的1变成了0，在数变成零前，能执行操作多少次，就有多少个1。
补充一下多态的知识
class Base
{
public:
	virtual void f(float x) {cout << "基类::f(float)函数" << x << endl;}
	virtual void f(int x, int y) {cout << "基类::f(int, int)函数" << x << "," << y << endl;}
	virtual void f1(float x) {cout << "基类::f1(float)函数" << x << endl;}
	void g(float x) {cout << "基类::g(float)函数" << x << endl;}
	void g(int x, int y) {cout << "基类::g(int, int)函数" << x << "," << y << endl;}
	void h(float x) {cout << "基类::h(float)函数" << x << endl;}
	static void my(float x) {cout << "基类::my(float)函数" << x << endl;}
};
class Derived : public Base
{
public:
	virtual void f(float x) {cout << "子类::f(float)函数" << x << endl;}
	virtual void f1(int x) {cout << "子类::f1(int)函数" << x << endl;}
	void g(int x) {cout << "子类::g(int)函数" << x << endl;}
	void h(float x) {cout << "子类::h(float)函数" << x << endl;}
	static void my(float x) {cout << "子类::my(float)函数" << x << endl;}
};
Derived oDerived;
Base *pBase = &oDerived;
Derived *pDerived = &oDerived;

pBase->f(3.14f);					 // 子类::f(float)函数3.14
pDerived->f(3.14f);					 // 子类::f(float)函数3.14

pBase->f(1, 2);						 //	基类::f(int, int)函数1,2
//pDerived->f(1, 2); 				 // 父类的f(int x, int y)被f(float x)屏蔽了，调用不了，编译错误

pBase->f1(3.14f);					 // 基类::f1(float)函数3.14
pDerived->f1(3.14f);				 // 子类::f1(int)函数3

// hide
pBase->g(3.14f);					 // 基类::g(float)函数3.14
pDerived->g(3.14f);					 // 子类::g(int)函数3

pBase->g(1, 2);						 // 基类::g(int, int)函数1,2
//pDerived->g(1, 2);  				 // 父类的g(int x, int y)被g(int x)屏蔽了，调用不了，编译错误

// hide
pBase->h(3.14f);					 // 基类::h(float)函数3.14
pDerived->h(3.14f);					 // 子类::h(float)函数3.14

pBase->my(3.14f);					 // 基类::my(float)函数3.14
pDerived->my(3.14f);				 // 子类::my(float)函数3.14

只有基类、子类的方法为虚方法，以及函数声明完全一致时，才可以实现多态调用。

面试题16：数值的整数次方
①考虑指数可能是正数也可能是负数
②计算指数时，循环的效率不高，可以采用“折半”的思想，比如2的32次方，可以使2的16次方的平方
float：1bit（符号位） 8bits（指数位） 23bits（尾数位）
double：1bit（符号位） 11bits（指数位） 52bits（尾数位）
二进制：0b
八进制：0
十六进制：0x

面试题17：打印从1到最大的n位数
①考虑到最大数可能超过int、甚至是longlong的表示范围
②用字符串或者数组来求解问题
字符'\0'的ASCII码值为0
strlen(number)		//串长度，不考虑'\0'
memset(number, '0', n)		//数组的前n位置0

面试题18：删除链表的节点
①可以把删除节点的后一个节点的值复制过来，然后再删除后一个节点
②如果是最后一个节点，那没办法，只能按个遍历，然后删除节点
③如果是第一个节点，也是最后一个节点，那么删除后需要把头结点置空

面试题19：正则表达式匹配
①可以使用递归来进行求解，变化成子问题的求解
②根据*的位置可变性，考虑多种匹配情况，完成比对逻辑

面试题20：表示数值的字符串
①定义扫描整数和，无符号整数的方法
②根据"."和"e/E"分割的字符串，进行扫描，依次进行判断

面试题21：调整数组顺序使奇数位于偶数前面
①两个指针，一个指向头，一个指向尾，逐渐逼近
②单前指针指向内容为偶，后指针指向内容为奇时，交换两个数字
考虑到代码的通用性，可以使用策略模式，或者函数指针的方式（不一定就是奇偶规则）
函数指针的用法
void sort( void(*func)(int) )
{
	func(10);
}
void bubbleSort(int n)
{
	cout << n << endl;
}
void main()
{
	sort(bubbleSort);
}

面试题22：链表中倒数第k个节点
①设置前后指针，前指针指向头先移动k-1，后指针指向头，然后同时移动，知道前指针为null
②考虑代码鲁棒性，前指针移动k-1时，可能已经是null了

面试题23：链表中环的入口节点
①第一步要确定有环，设定快慢指针，快指针一次走两步，慢指针一次走一步，如果快指针为空前能追上慢指针，则存在环
②追上的位置必定在环内，然后走一圈，回到该位置，可以得到环长度
③第二步，设定前后指针，前指针，先走环长度（n），然后后指针也开始走，相与处，就是环的开始位置

面试题24：反转链表
①链表反转，需要三个指针，前，中，后，指针，不然中指指针向前指针之后，就断裂了，后续无法继续逆置
②代码要考虑周全，考虑足够多的测试用例，上交之前仔细检测

面试题25：合并两个排序的链表
①比较两个链表的头节点，更小的那个节点，加入到新的链表，然后更小节点的那个链表，指针后移一位
②继续比较剩余的两个链表，知道一个链表遍历完成，整个合并操作结束
③为了保持代码的鲁棒性，需要考虑链表为空，再进行合并的特殊情况
采用了递归的思想，先确定一个元素位置之后，后一位，又是两个链表的合并操作在进行

面试题26：树的子结构
①需要遍历主树，找到某个节点R，与子树的根相同，
②判断主树的R节点的子树，是否跟B具有相同的结构。
子树根为空时，肯定满足
子树根不空，但是主树根为空时，肯定不满足
主子树根不同时，肯定不满足
此外，再递归的查看主树的左子树和子树的左子树，主树的右子树和子树的右子树
注意：树的指针特别多，需要特别考虑指针空的情况，仔细斟酌
注意：浮点数比较相等时，不能直接等号，因为计算机内表示小数有误差
bool Equal(double num1, double num2)
{
	if((num1-num2>-0.0000001) && (num1-num2<0.0000001))
	{
		return true;
	}
	return false;
}
注意：类内指针成员变量要初始化为空，不然可能访问到错误的内容，进入错误的逻辑

面试题27：二叉树的镜像
遍历树节点，然后交换左右孩子，递归的交换左右子树即可

面试题28：对称的二叉树
①前序遍历：根，左，右
②对称前序遍历：根，右，左
如果两个遍历结果一样，则是对称的二叉树
bool IsSymme(BinaryTreeNode* pRoot)
{
	return IsSymmetricalTree(pRoot, pRoot);
}
bool IsSymmetricalTree(BinaryTreeNode* pNode1, BinaryTreeNode* pNode2)
{
	return IsSymmetricalTree(pNode1->m_pLeft, pNode2->m_pRight) && IsSymmetricalTree(pNode1->m_pRight, pNode2->m_pLeft);
}

面试题29：顺时针打印矩阵
①一圈一圈打印，从左上角开始，while中止条件为: 打印轮数*2>行数 || 打印轮数*2>列数
总之打印的圈数，必须小于等于行的一半，且小于等于列的一半
②然后就是考虑打印一圈的功能
根据轮数，行列数，可以确定，打印终止的行列数 = 行列数-轮数
第一步：从左到右打印
第二步：从上到下打印
第三步：从右到左打印
第四步：从下到上打印   可能只有1,2,3步，不一定4步完整，根据终止行列号决定

附加：二维数组如何作为参数传入
//定义数组
int arr[3][3] =
{
	{ 1, 2, 3 },
	{ 2, 100, 4 },
	{ 3, 4, 5 },
};

// ①形参为二维数组，给定第二维度长度3
// 函数定义：myFunction1(int arr[][3])
cout << "函数一返回的中心元素是" << myFunction1(arr) << endl;
	
// ②形参为指向数组的指针，给定数组长度3
// 函数定义：myFunction2(int (*arr)[3])
// int (*arr)[3] 中：*arr 表示arr是一个指针；[3]表示指针指向的对象的类型是具有3个元素的数组；int表示该数组的元素是int类型的
cout << "函数二返回的中心元素是" << myFunction2(arr) << endl;
	
// ③形参为指针的指针，实参必须为指针，不能是数组名
// 函数定义：myFunction3(int** arr)
int* p[3];
p[0] = arr[0];
p[1] = arr[1];
p[2] = arr[2];
cout << "函数三返回的中心元素是" << myFunction3(p) << endl;

面试题30：包含min函数的栈
①新定义的栈，包含一个数据栈，和辅助栈（用于存放各个层级的最小值）
②压栈时，数据栈加入元素，辅助栈压入，栈顶和当前值的较小值
③出栈是，数据栈，辅助栈都出栈
④取最小值时，返回辅助栈栈顶即可。
const T& min() const; 后一个const表明函数min内部，不可改变成员变量。

面试题31：栈的压入、弹出序列
①如果下一个弹出数字刚好是栈顶数字，那么直接弹出；
②如果不是，那继续压栈，知道把需要弹出的数字压入为止
③如果所有数字都压入后仍未找到下一个弹出数字，则不是弹出序列
const char *ptr;
char const *ptr; 两者等价，表示ptr指向的内容不能变
char * const ptr; 表示ptr不可指向其他地址

面试题32：从上到下打印二叉树
（一）不分行从上到下打印二叉树
利用队列即可实现，层序遍历，简单
（二）分行从上到下打印二叉树
添加两变量，没吃出栈前，看看当前层还有多少没打印，下一层有多少个要打赢
（三）之字形打印二叉树
添加一个bool型控制是否拟输出，一个栈用来实现拟输出

面试题33：二叉搜索树的后序遍历序列
规则：二叉搜索树，左子树上的值都比根小，右子树的值都比根大
求解：给定数组最后一个元素为根，然后递归的判断左右子树即可

面试题34：二叉树中和为某一值的路径
①由于二叉树有分叉，要倒回去，所以要使用到栈结构求解问题
②在找到叶子节点后，判断一下，然后倒回上一层
③不使用stack，使用vector的push_back和pop_back，这样子既有栈的功能，又便于数据的顺序输出
需要划分子问题求解，从根开始寻找，减去跟值之后，再看子树中是否存在满足的子结果。
注意：回溯时，要主要将压入的最后元素出栈

面试题35：复杂链表的复制
方法1：依次复制N个节点到N‘，每一个N'找Sibling指针时，都要遍历这个元链表，所以时间复杂度O(n*n)
方法2：依次复制N个节点到N‘，并建立N到N'的映射中，然后遍历一遍原链表，如果有N->S,找到N’和S'，建立N'->S'。时间复杂度O(n)。空间换时间
方法3：跟方法2类似，不过，不建立映射，只是把N'放到N之后。然后从新遍历，建立Sibling
①A->B->C->D->E 变成 A->A'->B->B'->C->C'->D->D'->E->E'
②为A'到E'建立Sibling指针
③将链表拆分成两个

面试题36：二叉搜索树与双向链表
由于二叉搜索树的中序遍历，正好是有序的，所以采用中序遍历二叉树
①把当前根节点设为当前节点，递归，找到左树最大
②将最大->当前，最大<-当前
③将当前节点设为最大，右子树设为当前节点，继续②部分代码
注意：此题逻辑比较绕，关键是要不断变换当前最大的节点，然后递归处理左右子树，跟根节点的关系。

面试题37：序列化二叉树
根据树，得到前序遍历序列、中序遍历序列，进行序列化，反序列时，根据两个序列重建二叉树
缺点：必须取出全部序列才行，而且要求树中不能有重复的节点
①序列化时，前序遍历二叉树，空指针序列化成特殊字符“$”
写文件
char* fileName = "./test.txt";
ofstream fileOut;	//继承于基类ostream
fileOut.open(fileName);
Serialize(pRoot, fileOut); //Serialize(BinaryTreeNode* pRoot, ostream& stream)
fileOut << "aaaaaa";
fileOut.close();
读文件
ifstream fileIn;
char ch;
fileIn.open(fileName);
while (!fileIn.eof())
{
	fileIn >> ch;
	cout << ch;
}
fileIn1.close();

面试题38：字符串的排列
①把字符串划分为两部分：第一个字符，后面的字符
②交换第一个部分，和后面不同的字符
③再进行子递归，把第一个固定下来，第二部分再划分成两个部分。
直至到了串的末尾为止

面试题39：数组中出现次数超过一半的数字
常规解法：先排序O(logN)，然后遍历一遍O(N)，找到，总时间复杂度O（NlogN）
解法一：注意特殊性质，排序之后中间的数字，就是出现次数超过一半的数字，借助快速排序实现O(N)的算法
解法二：增加两个变量，记录数字，和出现个数，遍历一遍即可知
int result = numbers[0];
int times = 1;
for (int i = 0; i < nLength; ++i)
{
	if (times==0)
	{
		result = numbers[i];
		times = 1;
	}
	else
	{
		if (numbers[i]==result)
		{
			times++;
		}
		else
		{
			times--;
		}
	}
}
找到的数字要比其他所有数字之和都要多，最后使得time为1的数字，就是要找的
解法三：空间换时间，建立一个新数组array，等于原数组长度，初始所有为0，一个数组n出现一次，则array[n]+=1

面试题40：最小的k个数
常规解法：先排序O(logN)，然后遍历一遍O(N)，找到最小的k个数，总时间复杂度O（NlogN）
解法一：同面试题39，解法一，可以使用快速排序思想，一第k个数为轴，划分左右，如果坐标大于k个。再在左边寻找。小于k个，在右边寻找剩余O(N)
解法二：（适合处理海量数据）
①用一个大小为k的容器装最小的k个数
②当容器不足k个，直接加入，超过k个，如果新元素小于已有最大值，则删掉最大元素，再插入
时间复杂度 = 遍历O(N) * 插入容器O(logk) = O(Nlogk)
因为每次都要找容器中最大数，考虑使用最大堆实现，自己实现比较复杂，采用红黑树实现的set和multiset是很好的选择
#include<functional>   // 因为用了greater<int>，表示数据从大到小进行排列，对应的为less<int>
typedef multiset<int, greater<int>> intSet;

面试题41：数据流中的中位数
时间复杂度比较			插入的时间复杂度		得到中位数的时间复杂度
没有排序的数组			    O(1)						O(N)
排序的数组					O(N)						O(1)
排序的链表					O(N)						O(1)
二叉搜索树		    平均O(logN)，最差O(N)     平均O(logN)，最差O(N)
AVL(平衡二叉树)			   O(logN)						O(1)
最大堆和最小堆   		   O(logN)						O(1)
最佳方式：
自己建立一个类的数据结构，来实现插入和取出中位数
插入时：最大堆和最小堆来实现，两个堆的数据相差不超过1（交替插入，先插入小顶堆），保证最小堆的所有数字，都要大于最大堆中的数字。、
取出时：最大堆和最小堆元素个数和为奇数，则返回最小堆堆定，为偶数，则返回最大堆和最小堆和的一半
#include <algorithm> 							// 为了使用push_heap和pop_heap
max.push_back();								// max加入一个元素
push_heap(max.begin(), max.end(), less<T>());	// 从大到小重排元素
num = max[0];									// 保存最大元素
pop_heap(max.begin(), max.end(), less<T>());	// 将堆定元素和最后元素对调
max.pop_back();									// 移除最大元素
额外：判断奇数、偶数时，把数字与1相与（&），为0则为偶数

面试题42：连续子数组的最大和
常规解法：子数组有n(n+1)/2种，通过两层循环，在O(N*N)的时间复杂度下，可以得到最大的子数组
高效解法：结合动态规划的思想
①先看不断累加，前i-1个数，若累加和为负数，则更新最大数和为第i个数
②若累加和为正数，则把第i个数加上
③比较当前累加和是否比已有的最大数大，大的化，则更新
int nCurSum = 0;
int nGreatestSum = 0;
for (int i = 0; i < nLength; ++i)
{
	if (nCurSum <= 0) nCurSum = pData[i];
	else nCurSum += pData[i];

	if (nCurSum > nGreatestSum) nGreatestSum = nCurSum;
}
return nGreatestSum;

面试题43：1~n整数中1出现的次数
常规解法：遍历每一个数，然后每个数按位获取1的个数，最后进行累加，求出1的总个数
高效解法：
// 一的个数分为以下3个部分，以21345为例子
// ①1出现在首位的个数（1346-21345，10000-19999）：（1）首位为1，则剩下各位转整，再加1；（2）首位>1，则10^(剩下位数)
// ②1出现在除首位的的个数（1346-21346，0'1346-0'9999，1'0000-1'9999，2'0000-2'1345）:
// 简化一下就是：1346-9999，0000-9999，0000-1345；再简化就是：2倍的0000-9999；0000-9999中，易知：位数 * 10^(位数-1)
// ③1-1345的个数：递归调用即可获得
#include <cmath>    // 然后可以使用pow(2.5,2)函数来求次幂
unsigned int length = static_cast<unsigned int>(strlen(strN));  //强制类型转换

面试题44：数字序列中某一位的数字
常规解法：枚举每一个数字，然后挨个找，效率低下
高效解法：先除去0
1位数有 9*1位         1 * 9 * 10^(1-1)
2位数有 90*2位        2 * 9 * 10^(2-1)
3位数有 900*3位		  3 * 9 * 10^(3-1)     n * 9 * 10^(n-1)位
然后逐步缩小范围，就可以直接获取到值
①确定是几（i）位数，前面有多少位
②计算这个i位数，是i位数的第几个，保存在nDiv中
③计算出第Index位，所在的数字，保存在nNumReal中
④计算出第Index位，是数字（i位数）的第几位，保存在wei中

面试题45：把数组排成最小的数
常规解法：如题38，把数组的全排列求解出来，然后一个个比较，直至得到最小的数
高效解法：
①确定新的排序规则，将数组排序，然后挨个拼接起来，就能得到最小数
②如何确定数组两个数m，n的大小，拼接可能是mn、nm
mn < nm，则m前n后， m < n 
nm < mn，则n前m后，	n < m
mn = nm，m = n
注意：两个int数拼接后可能超出int表示范围，这是一个隐含的大数问题
（1）
#include <stdlib.h> 		// 为了使用qsort函数
函数原型：void qsort(void *base, size_t nelem, size_t width, int (*fcmp)(const void*,const void *))
base待排序的数组
nelem数组元数的个数（长度）
width每一个元素所占存储空间的大小
fcmp用于对数组元素进行比较的函数的指针（该函数是要自己写的）
int values[] = { 88, 56, 100, 2, 25 };
int cmpfunc (const void * a, const void * b)
{
   return ( *(int*)a - *(int*)b );				
}
qsort(values, 5, sizeof(int), cmpfunc); 		//values的元素是int，那么传入到cmpfunc里面的事int*，需要冲void*强制转换一下
（2）
#include <stdlib.h>	  // 则可以使用sprintf(char*, "%d", int); strcpy，strcat，strcmp

面试题46：把数字翻译成字符串
思路：递归，划分子问题，比如12258，视为1、2258,12、258，然后再不断递归处理下去
问题：1和2258中的2258拆分为：2、258，22,、58。。。。跟上一级12、258，具有重复计算项
解决：从后往前处理 
// [i][i+1，length-1]
// [i,i+1][i+2，length-1]
// [i,i+1]必须拼起来是个两位数才行，(converted >= 10 && converted <= 25)

面试题47：礼物的最大价值
思路：典型的动态规划求解，递归求解
f[i,j] = max(f[i-1,j],f[i,j-1]) + gift[i,j]

面试题48：最长不含重复字符的子字符串
蛮力解法：先找到所有子串，有O(N*N)，然后判断子串是否有重复字符O(N)，总时间复杂度O(N*N*N)
动态规划解法：
（1）第i个字符前面没有出现过，f(i)=f(i-1)+1
（2）第i个字符前面出现过：
①距离前面出现的位置的距离d > f(i)，说明第i个字符接上去，无重复，所以f(i)=f(i-1)+1
②距离前面出现的位置的距离d <= f(i)，说明第i个字符接上去，肯定重复了，所以max=f(i), f(i)=d
代码精华：
int* position = new int[26];
for (int i = 0; i < 26; ++i)
{
	position[i] = -1;				// 表明26个字母全都没出现过
}
出现过之后，position[str[i]-'a'] = i   // str为原始输出字符串

面试题49：丑数
思路简单，判断丑数，然后一直循环，找到第n个丑数，（龟速）
空间换时间的解法：
用一个Index长度数组保存各个丑数
①假设已有i个丑数排序完成，最大一个为M
②i个数都乘2，找到大于M的最小一个数计M2
  i个数都乘3，找到大于M的最小一个数计M3
  i个数都乘5，找到大于M的最小一个数计M5
③第i+1个丑数，是M2，M3，M5中的最小值
一直循环下去，直到找到第Index个丑数

面试题50：第一个只出现一次的字符
题目一：字符串中第一个只出现一次的字符
简单，遍历一遍数组，建立一个容器，保存每个字符出现次数，然后再遍历一次，就可以找到第一个次数为1的数字
题目二：字符流中第一个只出现一次的字符
简单，定义容器，接受一个字符流中的字符后，array[字符] = 位置，下次再有此字符，则把array[字符]=-1，与题目一类似

面试题51：数组中的逆序对
常规思路：遍历数组，每趟，在更后续元素比较，通过O(N*N)复杂度，可以找到答案
高效解法：利用归并排序的思想
①先把数组分割成子数组，统计出子数组中的逆对数目，并把子数组从小到大排序
②统计两个子数组构成的逆序对数目，两个指针，p1，p2，指向两个子数组末尾，p1>p2则p1与p2前的数字都是逆序对，
在新的数组末尾加入更大的数，更大的那个数的指针前移

面试题52：两个链表的第一个公共节点
蛮力法：第一链表长度m，第二链表长度n，遍历m期间，遍历n，时间复杂度O(mn)
高效解法：如果可以重后往前遍历，那么最后一个相同节点就是第一个公共节点，所以使用两个栈即可，时间复杂度O(m+n)
①两个栈分别入栈两个队列
②比较栈顶，如果节点相同，那么出栈，直到不相同的前一个，就是公共节点
更高效的解法：利用栈，相当于空间换时间，还可以遍历两次求解，时间复杂度O(m+n)
①第一次遍历，求出两个链表的长度m，n
②第二次遍历，让长度先走|m-n|步，然后一起往后走，知道出现一样的节点为止

面试题53：在排序数组中查找数字
题目一：数字在排序数组中出现的次数
思路：通过二分查找法，找到“第一个k”和“最后一个k”（分治、递归求解），个数就是end-start+1；时间复杂度O（logN）
题目二：0~n-1中缺失的数字
常规思路：利用公式n(n-1)/2求出0~n-1的和S1，然后求出数组元素的和S2，S1-S2为所求，时间复杂度O(N)
利用数组排序的特性，新思路：不在数字为m，那么比m小的数，index=值，比m大的数，inde<值
所以就是找到数组中，第一个下标与值不同的下标，（二分查找，时间复杂度O(logN)）
（right+left）>> 1可以用来表示除2;
题目三：数组中数值和下标相等的元素
常规思路：遍历呗，O（N）时间复杂度
新思路：二分查找，直接找到最好，如果mid位置值>mid，在左边找，如果mid位置的值<mid，在右边找，时间复杂度O(logN)

面试题54：二叉搜索树的第k大节点
思路：简单，只要熟悉中序遍历，就可以很快找到答案，中序遍历的第k节点，就是第k大节点

面试题55：二叉树的深度
题目一：求二叉树的深度
简单，从根开始，递归求左子树深度DeepL，右子树数深度DeepR，树的深度是左右子树深度较大值+1
题目二：平衡二叉树
常规思路：因为左右子树深度相差要小于1，所以递归判断左右子树，必须都是平衡的即可，但有重复遍历，影响性能
高效解法：以为前序遍历，所以计算子树深度存在重复，采用后续遍历即可解决

面试题56：数组中数字出现的次数
题目一：数组中只出现一次的两个数字
要点：
①一个数字和自己的异或结果为0，遍历一遍，挨个异或，最后结果，就是只出现一次的值
②存在两个只出现一次的数时，一直异或，最后结果一定不为零，因为是两个不同数的“异或值”
③为了要找两个数，在②中结果，找到二进制中第一个为1的位index，划分两部分{index位为1}、{index位不为1}
④在{index位为1}、{index位不为1}各找一个只出现一次的数字即可
resultXOR ^= data[i]; // 表示异或运算，不同则1，同则0，按位异或。任何数与0异或，为本身，与本身异或，为0
题目二：数组中唯一只出现一次的数字
要点：
①1-n数字的第i位之和，能被三整除，所求数的第i位为0，否则为1,
②再根据各个位，求出值即可

面试题57：和为s的数字
题目一：和为s的两个数字
常规解法：固定一个数字，然后依次比较，时间复杂度O(N*N)
高效解法：两个指针，指向最前，最后，和值<s，前指针后移，和值>s，后指针前移动，知直到直到合适的值为止，O（N）复杂度
题目二：和为s的连续正数序列
参考问题一的思路，定义前数=1，后数=2，和=s则找到，和>s,前数+1，和<s，后数+1
注意：前数最多到（1+s）/ 2，否则肯定超过了s了。
小技巧：连续数字求和时，每步有很多重复的数子，可以吧上次的求和的值保存起来，每次在这个基础上，加减，可以减少很多重复计算

面试题58：翻转字符串
题目一：翻转单词顺序
思路：
先把整个字符串翻转"I am a student."变成".tneduts a ma I"
再将空格前面的一段，翻转".tneduts"->"student.", "a"->"a", "ma"->"am", "I"->"I"
题目二：左旋字符串
思路：
以"abcdefg"，2，为例子，把字符串分为两部分 "ab","cdefg", 分别旋转变成，"ba","gfedc"，"bagfedc"
"bagfedc"整个旋转，变成"cdefgab"，为所求。
注意：字符串的边界要特别小心，空指针也要判断
int nLength = static_cast<int>(strlen(pStr));

面试题59：队列的最大值
题目一：滑动窗口的最大值
常规解法；找到所有滑动窗口O(N)，在窗口的k个值里寻找最大值，O(K)，总时间复杂度O(NK)
高效解法：
定义一个队列，保存滑动窗口最大值，窗口滑动时，不需要考虑前面两个数，只要比较当前新数和最大值即可
时间复杂度变为O(N)
题目二：队列的最大值
简单：多定义一个辅助队列用来保存最大值，类似题目一和面试题30

// 使用一个数组初始化一个vector
int array[] = { 2, 3, 4, 2, 6, 2, 5, 1 };
vector<int> num(array, array + sizeof(array) / sizeof(int));  // [array,array+sizeof(array)/sizeof(int)) 闭开区间

struct InternalData
{
	T number;
	int index;
};
InternalData internalData = { number, currentIndex };    // 结构体可以用这种方式进行初始化

面试题60：n个骰子的点数
解法一：把n个骰子分为（1，n-1）个，n-1个骰子分为（1，n-2）个，知道只剩下一个位置，求不同值的出现次数
当num数很大时，递归数次数过多，导致时间性能很差
解法二：定义两个数组，数组1，保存前n-2个骰子的各值出现次数，数组2，保存加入第n-1个筛子后前n-1个骰子，各值出现次数
然后，一个一个骰子的加，循环求解，减少了重复的计算，时间效率比较高
f(i) = f(i-1)+f(i-2)...+f(i-6)

面试题61：扑克牌中的顺子
思路：
①把数组排序
②统计出数组中0的个数
③统计排序数组中相邻数字之间的空缺总数   numberOfGap += numbers[big] - numbers[small] - 1;
如果0的个数>=空缺总数，那么就是就是顺子。
注意：如果非零数字重复出现，则不是顺子。

面试题62：圆圈中最后剩下的数字
解法一：构建一个n环形链表，设置前后指针，然后遍历m次，时间复杂度O（mn），空间复杂度O（n）
解法二：找到数学规律，直接计算出值，时间复杂度O（n），空间复杂度O（1）
f（n，m） =	0 （n=1）， [f(n-1,m)+m]%n （n>1）

面试题63：股票的最大利润
蛮力法：遍历一遍数组，以i买入，计算i+1到length-1的利润，两层循环，O（N*N）的时间复杂度
高效解法：遍历一遍即可，查看i时，记录下前面i-1的最小值。比较各个i与前面i-1最小值的差，找到最大一个，就是最高利润

面试题64：求1+2+...+n
不能使用乘除法，循环，条件判断，switch，条件判断语句
解法1：利用构造函数，实现循环，打到求和的效果
Temp* a = new Temp[n];    // new一个数组
delete[] a;				  // 释放空间
a = NULL;				  // 避免野指针
解法2：利用虚函数求解（递归求解）
基类的函数，用于中止递归
子类的函数，用于递归处理
注意：对n连续两次求反，即!!n，n转化为true，0转化为false
解法3：和解法2类似，不过是利用了C的函数指针，来实现多态
typedef unsigned int(*fun)(unsigned int n);   // 定义函数指针，fun
static fun f[2] = { SumFunction3_End, SumFunction3 };  // 使用，f[0],f[1]都是fun类型，指向两个函数
f[0](n);	// 直接括号参数即可使用
解法4：利用模板类求解（暂时不能理解）
template <unsigned int n>
struct SumFunction4
{
	enum Value { N = SumFunction4<n - 1>::N + n };
};
template <> struct SumFunction4<1>
{
	enum Value { N = 1 };
};
SumFunction4<10>::N   就是1..10的累加和

面试题65：不用加减乘除做加法
思路：位运算求解
①sum = a ^ b   a和b的二进制，无进位相加  异或运算正好满足
②carry = (a & b) << 1    生成进位
然后 a = sum ，b = carry，重复①②两步，知道b为0时，a为所求

面试题66：构建乘积数组
C[i]=A[0]*A[1]*...*A[i-1]
D[i]=A[i+1]*...*A[n-2]*A[n-1]
=>得出递推关系式
C[i] = C[i-1] * A[i-1];
D[i] = D[i+1] * A[i+1];
最后所求为C[i] * D[i]，采用分治的算法即可求解


9.1    		递归和动态规划 	 	上楼梯
9.2-2  		递归和动态规划  	机器人走方格II
9.5    		递归和动态规划 	 	字符串排列
无序号 		递归	        	洪水
9.8	  		递归和动态规划  	硬币表示
9.9    		递归和动态规划  	n皇后问题
9.10(*)   	递归和动态规划		堆箱子           
11.7	  	排序和查找			叠罗汉I
17.8		贪心				最大连续数列和
18.1		数学思维			另类加法
18.4(*)		数学基础			2的个数
18.10		字符串及队列		字符串变换

高频遗忘：
面试题7：二叉树几种遍历的非递归算法
面试题15：多态的知识复习
面试题29：二维数组作为传参的使用
面试题40：最小的K个数
面试题59：使用一个数组初始化vector

select、poll、epoll